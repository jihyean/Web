## 오전 9:17 2023-07-05


${datas}
scope는 알 수 없지만 
	req, sess, app
.getAttribue()
=> C가 setAttribute()
	M로부터 받아온 
	DB로부터 받아온 서버 데이터임

${param.datas}
req.getParameter()
=> 사용자가 form 등을 이용하여 전달된 데이터구나

if의 test는 필수속성이지만'
foreach문은 필수속성이 없다 ---> begin등으로 컨트롤 가능해서

//=============================================

[커스텀태그]

	ex) JSTL --->> .jar x2 필수(자원없이 사용불가)
<html>
<body>
<title>
<div>
<a>
.
.
.
등등이 기본 태그

포폴에 넣으셈
1) 이거 왜 씀? 
	---> "View"에서 사용하는 모듈화 기법중 하나인데
		유지보수 용이
		코드의 재사용성 증가
		가독성 증가
			:비용절감
2) 기능/기술이 뭐임? 
	팀원이 개발한 것 아니여도 숙지할것


[필터(.java 클래스)]
매우 중요하기 때문에 이미 다 기본으로 들어가 있어서 오히려 모르고 씀

눈에 띄라고 헉!!!!!!! 경쟁력

1) 왜 씀?
	--->사용자(브라우저, 클라이언트)의 요청에
		특정 기능을 부여하기 위해 사용
		ex)인코딩, 데이터 정제, 권한체크, 로그, 보안,...
		필터는 요청에 대해 기능을 부여할때 사용

데이터를 받아서 원하는 데이터만 거르거나 정제하는 역할
어떠한 데이터를 보내주기 전에 보여주기 전에 확인한다

2) 필터 클래스는 언제 동작됩니까?
		V --- 필터클래스(기능 부여) --->>C
		사용자(브라우저, 클라이언트)의 요청 직후에 호출
		Filter mappings 설정한대로 호출
대표적인 Not POJO
severlet
Listener
filter

개구식인 완전 기초적인거
	클래스 파일로 생성할때부터 이미 import가 많이 되어 있는 상태
	기본 기능들이 이미 많이 있음
 



POJO
ex) StudentVO, Car, Point
	일반적인 Class 파일로 만들 수 있는 자바 클래스 객체

// @ 어노테이션(애너테이션)이라고 함
// 자바 문법이며 코드에 대한 설정을 나타냄
메모리를 정리하며 더 빠르고 효율적이게 작동함

@WebFilter("*.jsp")
// 원래 안해도 작동하지만
// 얘는 언제 작동할지이기 때문에 없으면 작동하지 않음

생성자 기본 생성자

init 최초로 필터 생성할때 자동 호출 ---> 단1번 호출됨
NOT POJO들은 멤버변수 초기화를 일반적으로 init에서 함
생성자에서 너무 많이 일하기 때문


destory
필터가 메모리에서 해제될때 호출
보안일 경우 보안을 마치겠다는 의미이기 때문에
보안셧다운 로그로 많이 사용한다

doFilter
chain.doFilter(request, response);
//사용자의 요청
인코딩 처리 로직은 상단에 넣음
다음 페이지가 불러와지기 전에 처리해야 하기 때문에
// 사용자의 요청정보들을 보고 어디서 무엇을 요청했는지 찾아서 다음페이지로 이동하기 때문에
// 이동전에 인코딩해야 함


톰캣 내장 서버는 web info 하위에 web.xml 봐~~라고 지들끼리 이미 정해놓음

외부파일로 불러와서 사용하면 좋은점
자바를 재작성하게 되면 컴파일이 필요합니다
---> 서버가 1초이상 정지 == 사용자가 그동안 이용하지 못함


실습01
인코딩 다 제거한뒤 필터로 변경
커스텀태그 구현

